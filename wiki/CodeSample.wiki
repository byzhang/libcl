#summary A few snippets of source code illustrating how to extend libCL.
#labels Phase-Implementation,Featured

= Introduction =

The following is an example of how to intgerate additional OpenCL algorithms into libCL. 

= oclToneMapping.h =

{{{
#include "oclRecursiveGaussian.h"

class oclToneMapping : public oclProgram
{
    public: 

        oclToneMapping(oclContext& iContext, cl_image_format iFormat = sDefaultFormat);

        int compile();
        int compute(oclDevice& iDevice, oclImage2D& bfSrce, oclImage2D& bfDest);

        void setSmoothing(cl_float iValue);

    protected:

        oclRecursiveGaussian mGaussian;

        oclKernel clLuminance;
        oclKernel clCombine;

        oclImage2D bfTempA;
        oclImage2D bfTempB;

        static cl_image_format sDefaultFormat;
};      
}}}

= oclToneMapping.cpp =

{{{
#include "oclToneMapping.h"

oclToneMapping::oclToneMapping(oclContext& iContext, cl_image_format iFormat)
: oclProgram(iContext, "oclToneMapping")
// buffers
, bfTempA(iContext, "bfTemp0")
, bfTempB(iContext, "bfTemp1")
// kernels
, clLuminance(*this)
, clCombine(*this)
// programs
, mGaussian(iContext)
{
    bfTempA.create(CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR, iFormat, 256, 256);
    bfTempB.create(CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR, iFormat, 256, 256);

    addSourceFile("image\\oclToneMapping.cl");

    exportKernel(clLuminance);
    exportKernel(clCombine);
}

int oclToneMapping::compile()
{
    // release kernels
    clLuminance = 0;
    clCombine = 0;

    if (!mGaussian.compile())
    {
        return 0;
    }
    if (!oclProgram::compile())
    {
        return 0;
    }

    clLuminance = createKernel("clLuminance");
    KERNEL_VALIDATE(clLuminance)
    clCombine = createKernel("clCombine");
    KERNEL_VALIDATE(clCombine)
    return 1;
}

int oclToneMapping::compute(oclDevice& iDevice, oclImage2D& bfSrce, oclImage2D& bfDest)
{
    cl_uint lWidth = bfSrce.getImageInfo<size_t>(CL_IMAGE_WIDTH);
    cl_uint lHeight = bfSrce.getImageInfo<size_t>(CL_IMAGE_HEIGHT);

    if (bfTempA.getImageInfo<size_t>(CL_IMAGE_WIDTH) != lWidth || bfTempA.getImageInfo<size_t>(CL_IMAGE_HEIGHT) != lHeight)
    {
        bfTempA.resize(lWidth, lHeight);
    }
    if (bfTempB.getImageInfo<size_t>(CL_IMAGE_WIDTH) != lWidth || bfTempB.getImageInfo<size_t>(CL_IMAGE_HEIGHT) != lHeight)
    {
        bfTempB.resize(lWidth, lHeight);
    }

    size_t lGlobalSize[2];
    lGlobalSize[0] = lWidth;
    lGlobalSize[1] = lHeight;

    clSetKernelArg(clLuminance, 0, sizeof(cl_mem), bfSrce);
    clSetKernelArg(clLuminance, 1, sizeof(cl_mem), bfTempA);
    sStatusCL = clEnqueueNDRangeKernel(iDevice, clLuminance, 2, NULL, lGlobalSize, NULL, 0, NULL, clLuminance.getEvent());
    ENQUEUE_VALIDATE

    if (!mGaussian.compute(iDevice, bfTempA, bfTempB, bfTempA))
    {
        return false;
    }

    clSetKernelArg(clCombine, 0, sizeof(cl_mem), bfSrce);
    clSetKernelArg(clCombine, 1, sizeof(cl_mem), bfTempA);
    clSetKernelArg(clCombine, 2, sizeof(cl_mem), bfDest);
    sStatusCL = clEnqueueNDRangeKernel(iDevice, clCombine, 2, NULL, lGlobalSize, NULL, 0, NULL, clCombine.getEvent());
    ENQUEUE_VALIDATE

    return true;
}


void oclToneMapping::setSmoothing(cl_float iValue)
{
    mGaussian.setSigma(iValue);
}
}}}